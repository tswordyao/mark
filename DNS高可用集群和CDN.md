## DNS 高可用集群

```
1.内网调用DNS	一般是每个机房一组，做ms结构，主要功能是供机房内部应用之间调用解析，减少对hosts的依赖，避免硬编码。一般ms结构就可以了，不太会做其他的高可用。	

2.回源调用dns	和内网调用dns功能差不多，不过这个是跨机房的调用，而且一般会通过view做智能dns解析。	比较常见的应用场景就是webcdn的回源dns，结构上和内部调用dns差不多。	

3.外网dns	提供各种针对外网的解析，A记录，CNAME，MX等等。。	作为用户访问的入口，其重要性也不言而喻，因此对可用性和扩展性以及性能要求会比较高。	

一般的做法是在BGP机房做一个高可用的集群做主要的解析工作，同时在双线或者单线机房做一组冷备的高可用DNS集群。	
这里讨论下用lvs做dns高可用的方案，主要借鉴了mySQL高可用的方案（一般都是一个主库，后面挂多个丛库，丛库前面使用lvs+keepalived做ha，程序写入主库，读取丛库）。	

具体的流程如下：	
1.用户通过web前端来做dns的增删改等操作（如果是python程序的话，可以通过dnspython操作）。	
2.slave通过对比zone文件的serial值来决定是否需要更新记录。	
3.用户查询请求至由lvs(dr模式)+keepalived组成的前端负载均衡。	4.lvs分发请求至slave server,最后由slave server直接向用户响应请求。
```

## CDN的访问步骤：

```
step1：用户向localDNS发起请求查询输入域名对应的IP地址（若有缓存直接返回，否则去rootDNS查询）；

step2：localDNS迭代向rootDNS查询，逐级迭代,rootDNS=>顶级DNS=>权限DNS；

step3：获得权限DNS后，localDNS向权限DNS发起域名解析请求；

step4：权限DNS通常会将域名CNAME【如果有有CNAME则解析CNAME对应的CDN服务，否则的话默认为普通请求，直接返回解析到的IP】到另一个域名，这个域名最终会被指向CDN网络中的智能DNS负载均衡系统；

step5：DNS负载均衡系统通过一些智能算法，将最合适的CDN节点IP地址返回给localDNS；

step6：localDNS将获得的IP地址返回给用户；

step7：用户得到节点的IP地址后，向该节点发起访问请求；

step8：CDN节点返回请求文件，如果该节点中请求的文件不存在，就会再回到源站获取这个文件，然后


生产环境中我们都用什么做负载均衡器?
财大气粗的用硬件F5
不差钱的使用DNS负载均衡
技术牛逼的用LVS
苦逼的创业型小公司只能使用Nginx
当然，负载均衡器不止以上几种，有兴趣的同学自行谷歌了解。


再来一张TCP/IP五层模型，在每一层都工作着不同的设备。
比如财大气粗，不差钱的国企使用的F5工作在4-7层，
一般互联网企业使用的LVS工作在传输层，
使用最广泛的Nginx工作在应用层。

最后来聊一下DNS负载均衡，虽然DNS最原始也是最简单的方法，但是DNS负载均衡的控制权在域名服务商手里，NDS存在多级解析，缓存A记录的问题，以及网站自身无法做更多的管理。这样导致了一般中小公司很少使用。
当然，自身实力够硬，DNS负载均衡也是个不错的选择。下图是检测TT猫域名的A记录得到的部分信息，仅供参考，自行领悟


最近接触并使用了阿里云的负载均衡SLB ，大体了解了一下TT猫的负载均衡实现，以下架构实现源于TT猫。
负载均衡采用集群部署，可实现会话同步，以消除服务器单点故障，提升冗余，保证服务的稳定性。阿里云当前提供四层(TCP协议和UDP协议)和七层(HTTP和HTTPS协议)的负载均衡服务。
四层采用开源软件LVS(Linux Virtual Server)+ keepalived的方式实现负载均衡。
七层采用Tengine实现负载均衡。

如下图所示，各个地域的四层负载均衡实际上是由多台LVS机器部署成一个LVS集群来运行的。采用集群部署模式极大地保证了异常情况下负载均衡服务的可用性、稳定性与可扩展性。

LVS集群内的每台LVS都会进行会话，通过组播报文同步到该集群内的其它LVS机器上，从而实现LVS集群内各台机器间的会话同步。如下图所示，当客户端向服务端传输三个数据包后，在LVS1上建立的会话A开始同步到其它LVS机器上。图中实线表示现有的连接，图中虚线表示当LVS1出现故障或进行维护时，这部分流量会走到一台可以正常运行的机器LVS2上。因而负载均衡集群支持热升级，并且在机器故障和集群维护时最大程度对用户透明，不影响用户业务。
```

